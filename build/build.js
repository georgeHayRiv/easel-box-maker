// Generated by CoffeeScript 1.10.0
var SVG, executor, flatten, panel, properties, rotate, side, tabSizes, test, translate;

SVG = (function() {
  var element, properties, propertyValue, render, root, rotate, scale, translate;
  propertyValue = function(value) {
    if (value.map) {
      return value.map(propertyValue).join(" ");
    } else {
      if (value.toFixed) {
        return value.toFixed(5);
      } else {
        return value + "";
      }
    }
  };
  properties = function(obj) {
    var key, results, value;
    results = [];
    for (key in obj) {
      value = obj[key];
      results.push(key + "=\"" + (propertyValue(value)) + "\"");
    }
    return results;
  };
  render = function(element) {
    return "<" + element.tag + " " + (properties(element.props).join(" ")) + ">" + (element.children.map(render).join(" ")) + "</" + element.tag + ">";
  };
  element = function(tag, props, children) {
    if (props == null) {
      props = {};
    }
    if (children == null) {
      children = [];
    }
    return {
      tag: tag,
      props: props,
      children: children
    };
  };
  root = function(width, height, units) {
    if (units == null) {
      units = "in";
    }
    return element('svg', {
      width: width + units,
      height: height + units,
      viewBox: "0 0 " + width + " " + height
    });
  };
  translate = function(x, y, el) {
    return element('g', {
      transform: "translate(" + x + " " + y + ")"
    }, [el]);
  };
  rotate = function(degrees, el) {
    return element('g', {
      transform: "rotate(" + degrees + ")"
    }, [el]);
  };
  scale = function(x, y, el) {
    return element('g', {
      transform: "scale(" + x + " " + y + ")"
    }, [el]);
  };
  return {
    element: element,
    root: root,
    translate: translate,
    rotate: rotate,
    scale: scale,
    render: render
  };
})();

tabSizes = function(length, tabLength) {
  var segments;
  segments = Math.floor(Math.floor(length / tabLength) / 2) * 2 + 1;
  return {
    tabSize: length / segments,
    gapSize: length / segments,
    tabCount: segments
  };
};

flatten = function(arr) {
  var collector, i, len, subarr;
  collector = [];
  for (i = 0, len = arr.length; i < len; i++) {
    subarr = arr[i];
    collector = collector.concat(subarr);
  }
  return collector;
};

side = function(length, tabLength, tabOffset, tabStart, tabLeft, tabRight) {
  var endX, gapSize, index, ref, segments, startX, tabCount, tabSize, y;
  ref = tabSizes(length, tabLength), tabSize = ref.tabSize, gapSize = ref.gapSize, tabCount = ref.tabCount;
  segments = (function() {
    var i, ref1, results;
    results = [];
    for (index = i = 0, ref1 = tabCount; 0 <= ref1 ? i < ref1 : i > ref1; index = 0 <= ref1 ? ++i : --i) {
      startX = tabSize * index;
      endX = tabSize * (index + 1);
      if (index === 0 && !tabLeft) {
        startX += tabOffset;
      } else if (index === (tabCount - 1) && !tabRight) {
        endX -= tabOffset;
      }
      y = tabOffset * ((index % 2 !== 0) === tabStart);
      results.push([[startX, y], [endX, y]]);
    }
    return results;
  })();
  return flatten(segments);
};

panel = function(width, height, tabLength, tabOffset, tabs) {
  return flatten([side(width, tabLength, tabOffset, tabs.bottom, tabs.left, tabs.right), translate(width, 0, rotate(Math.PI / 2, side(height, tabLength, tabOffset, tabs.right, tabs.bottom, tabs.top))), translate(width, height, rotate(Math.PI, side(width, tabLength, tabOffset, tabs.top, tabs.right, tabs.left))), translate(0, height, rotate(3 * Math.PI / 2, side(height, tabLength, tabOffset, tabs.left, tabs.top, tabs.bottom)))]);
};

translate = function(x, y, pointArray) {
  var i, len, point, results;
  results = [];
  for (i = 0, len = pointArray.length; i < len; i++) {
    point = pointArray[i];
    results.push([point[0] + x, point[1] + y]);
  }
  return results;
};

rotate = function(angle, pointArray) {
  var i, len, point, results;
  results = [];
  for (i = 0, len = pointArray.length; i < len; i++) {
    point = pointArray[i];
    results.push([point[0] * Math.cos(angle) - point[1] * Math.sin(angle), point[0] * Math.sin(angle) + point[1] * Math.cos(angle)]);
  }
  return results;
};

properties = [
  {
    id: "Width",
    type: "range",
    value: 4,
    min: 0,
    max: 10,
    step: 0.1
  }, {
    id: "Height",
    type: "range",
    value: 3,
    min: 0,
    max: 10,
    step: 0.1
  }, {
    id: "Depth",
    type: "range",
    value: 5,
    min: 0,
    max: 10,
    step: 0.1
  }, {
    id: "Tab Length",
    type: "range",
    value: 0.75,
    min: 0,
    max: 2,
    step: 0.1
  }, {
    id: "Material Thickness",
    type: "range",
    value: 0.25,
    min: 0,
    max: 0.5,
    step: 0.01
  }
];

executor = function(params, success, failure) {
  var height, inputs, svg, tabLength, tabOffset, thinPolygon, width, x, xy, xyTabs, xz, xzTabs, y, yz, yzTabs, z;
  inputs = params[0];
  x = inputs["Width"];
  y = inputs["Height"];
  z = inputs["Depth"];
  tabLength = inputs["Tab Length"];
  tabOffset = inputs["Material Thickness"];
  xyTabs = {
    top: true,
    bottom: true,
    left: true,
    right: true
  };
  xzTabs = {
    top: false,
    bottom: false,
    left: true,
    right: true
  };
  yzTabs = {
    top: false,
    bottom: false,
    left: false,
    right: false
  };
  width = Math.ceil(2 * x + 2 * y + 4 * tabOffset);
  height = Math.ceil(2 * y + 2 * z + 4 * tabOffset);
  svg = SVG.root(width, height);
  thinPolygon = function(points) {
    return SVG.element('polygon', {
      points: points,
      fill: 'none',
      stroke: '#000',
      'stroke-width': 0.01
    });
  };
  xy = thinPolygon(panel(x, y, tabLength, tabOffset, xyTabs));
  svg.children.push(xy);
  svg.children.push(SVG.translate(0, y + tabOffset, xy));
  xz = SVG.translate(0, 2 * y + 2 * tabOffset, thinPolygon(panel(x, z, tabLength, tabOffset, xzTabs)));
  svg.children.push(xz);
  svg.children.push(SVG.translate(0, z + tabOffset, xz));
  yz = SVG.translate(x + z + tabOffset, 0, SVG.rotate(90, thinPolygon(panel(y, z, tabLength, tabOffset, yzTabs))));
  svg.children.push(yz);
  svg.children.push(SVG.translate(0, y + tabOffset, yz));
  return success(SVG.render(svg));
};

test = function() {
  var i, len, params, prop, success;
  success = function(output) {
    return console.log(output);
  };
  params = {};
  for (i = 0, len = properties.length; i < len; i++) {
    prop = properties[i];
    params[prop.id] = prop.value;
  }
  return executor([params], success);
};

if ((typeof module !== "undefined" && module !== null) && (typeof require !== "undefined" && require !== null ? require.main : void 0) === module) {
  test();
}
