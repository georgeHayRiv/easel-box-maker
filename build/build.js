// Generated by CoffeeScript 1.10.0
var Box, SVG, Utils, executor, i, len, onSuccess, params, prop, properties;

SVG = (function() {
  var element, properties, propertyValue, render, root, rotate, scale, translate;
  propertyValue = function(value) {
    if (value.map) {
      return value.map(propertyValue).join(" ");
    } else {
      if (value.toFixed) {
        return value.toFixed(5);
      } else {
        return value + "";
      }
    }
  };
  properties = function(obj) {
    var key, results, value;
    results = [];
    for (key in obj) {
      value = obj[key];
      results.push(key + "=\"" + (propertyValue(value)) + "\"");
    }
    return results;
  };
  render = function(element) {
    return "<" + element.tag + " " + (properties(element.props).join(" ")) + ">" + (element.children.map(render).join(" ")) + "</" + element.tag + ">";
  };
  element = function(tag, props, children) {
    if (props == null) {
      props = {};
    }
    if (children == null) {
      children = [];
    }
    return {
      tag: tag,
      props: props,
      children: children
    };
  };
  root = function(width, height, units) {
    if (units == null) {
      units = "in";
    }
    return element('svg', {
      width: width + units,
      height: height + units,
      viewBox: "0 0 " + width + " " + height
    });
  };
  translate = function(x, y, el) {
    return element('g', {
      transform: "translate(" + x + " " + y + ")"
    }, [el]);
  };
  rotate = function(degrees, el) {
    return element('g', {
      transform: "rotate(" + degrees + ")"
    }, [el]);
  };
  scale = function(x, y, el) {
    return element('g', {
      transform: "scale(" + x + " " + y + ")"
    }, [el]);
  };
  return {
    element: element,
    root: root,
    translate: translate,
    rotate: rotate,
    scale: scale,
    render: render
  };
})();

Utils = (function() {
  return {
    translate: function(x, y, pointArray) {
      var i, len, point, results;
      results = [];
      for (i = 0, len = pointArray.length; i < len; i++) {
        point = pointArray[i];
        results.push([point[0] + x, point[1] + y]);
      }
      return results;
    },
    rotate: function(angle, pointArray) {
      var i, len, point, results;
      results = [];
      for (i = 0, len = pointArray.length; i < len; i++) {
        point = pointArray[i];
        results.push([point[0] * Math.cos(angle) - point[1] * Math.sin(angle), point[0] * Math.sin(angle) + point[1] * Math.cos(angle)]);
      }
      return results;
    },
    flatten: function(arr) {
      return arr.reduce(function(collector, subarr) {
        return collector.concat(subarr);
      });
    }
  };
})();

Box = function(params) {
  var panel, side, tabSizes, xy, xz, yz;
  tabSizes = function(length, tabLength) {
    var segments;
    segments = Math.floor(Math.floor(length / tabLength) / 2) * 2 + 1;
    return {
      tabSize: length / segments,
      gapSize: length / segments,
      tabCount: segments
    };
  };
  side = function(length, tabLength, tabOffset, tabStart, tabLeft, tabRight) {
    var endX, gapSize, index, ref, segments, startX, tabCount, tabSize, y;
    ref = tabSizes(length, tabLength), tabSize = ref.tabSize, gapSize = ref.gapSize, tabCount = ref.tabCount;
    segments = (function() {
      var i, ref1, results;
      results = [];
      for (index = i = 0, ref1 = tabCount; 0 <= ref1 ? i < ref1 : i > ref1; index = 0 <= ref1 ? ++i : --i) {
        startX = tabSize * index;
        endX = tabSize * (index + 1);
        if (index === 0 && !tabLeft) {
          startX += tabOffset;
        } else if (index === (tabCount - 1) && !tabRight) {
          endX -= tabOffset;
        }
        y = tabOffset * ((index % 2 !== 0) === tabStart);
        results.push([[startX, y], [endX, y]]);
      }
      return results;
    })();
    return Utils.flatten(segments);
  };
  panel = function(width, height, tabLength, tabOffset, tabs) {
    var flatten, rotate, translate;
    flatten = Utils.flatten, translate = Utils.translate, rotate = Utils.rotate;
    return flatten([side(width, tabLength, tabOffset, tabs.bottom, tabs.left, tabs.right), translate(width, 0, rotate(Math.PI / 2, side(height, tabLength, tabOffset, tabs.right, tabs.bottom, tabs.top))), translate(width, height, rotate(Math.PI, side(width, tabLength, tabOffset, tabs.top, tabs.right, tabs.left))), translate(0, height, rotate(3 * Math.PI / 2, side(height, tabLength, tabOffset, tabs.left, tabs.top, tabs.bottom)))]);
  };
  xy = function() {
    var xyTabs;
    xyTabs = {
      top: true,
      bottom: true,
      left: true,
      right: true
    };
    return panel(params.x, params.y, params.tabLength, params.tabOffset, xyTabs);
  };
  xz = function() {
    var xzTabs;
    xzTabs = {
      top: false,
      bottom: false,
      left: true,
      right: true
    };
    return panel(params.x, params.z, params.tabLength, params.tabOffset, xzTabs);
  };
  yz = function() {
    var yzTabs;
    yzTabs = {
      top: false,
      bottom: false,
      left: false,
      right: false
    };
    return panel(params.y, params.z, params.tabLength, params.tabOffset, yzTabs);
  };
  return {
    xy: xy,
    xz: xz,
    yz: yz
  };
};

properties = [
  {
    id: "Width",
    type: "range",
    value: 4,
    min: 0,
    max: 10,
    step: 0.1
  }, {
    id: "Height",
    type: "range",
    value: 3,
    min: 0,
    max: 10,
    step: 0.1
  }, {
    id: "Depth",
    type: "range",
    value: 5,
    min: 0,
    max: 10,
    step: 0.1
  }, {
    id: "Tab Length",
    type: "range",
    value: 0.75,
    min: 0,
    max: 2,
    step: 0.1
  }, {
    id: "Material Thickness",
    type: "range",
    value: 0.25,
    min: 0,
    max: 0.5,
    step: 0.01
  }
];

executor = function(params, success, failure) {
  var box, height, inputs, svg, tabLength, tabOffset, thinPolygon, width, x, xy, xz, y, yz, z;
  inputs = params[0];
  x = inputs["Width"];
  y = inputs["Height"];
  z = inputs["Depth"];
  tabLength = inputs["Tab Length"];
  tabOffset = inputs["Material Thickness"];
  box = Box({
    x: x,
    y: y,
    z: z,
    tabLength: tabLength,
    tabOffset: tabOffset
  });
  width = Math.ceil(2 * x + 2 * y + 4 * tabOffset);
  height = Math.ceil(2 * y + 2 * z + 4 * tabOffset);
  svg = SVG.root(width, height);
  thinPolygon = function(points) {
    return SVG.element('polygon', {
      points: points,
      fill: 'none',
      stroke: '#000',
      'stroke-width': 0.01
    });
  };
  xy = thinPolygon(box.xy());
  svg.children.push(xy);
  svg.children.push(SVG.translate(0, y + tabOffset, xy));
  xz = SVG.translate(0, 2 * y + 2 * tabOffset, thinPolygon(box.xz()));
  svg.children.push(xz);
  svg.children.push(SVG.translate(0, z + tabOffset, xz));
  yz = SVG.translate(x + z + tabOffset, 0, SVG.rotate(90, thinPolygon(box.yz())));
  svg.children.push(yz);
  svg.children.push(SVG.translate(0, y + tabOffset, yz));
  return success(SVG.render(svg));
};


/*
  For testing, mimic a call to executor using the default properties
  Only run if this file is being run directly (i.e. require.main === module)
 */

if ((typeof module !== "undefined" && module !== null) && (typeof require !== "undefined" && require !== null ? require.main : void 0) === module) {
  onSuccess = function(output) {
    return console.log(output);
  };
  params = {};
  for (i = 0, len = properties.length; i < len; i++) {
    prop = properties[i];
    params[prop.id] = prop.value;
  }
  executor([params], onSuccess);
}
